<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-19T05:32:48+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jaeho Kim</title><subtitle>my new homepage</subtitle><author><name>Jaeho Kim</name></author><entry><title type="html">창의성에 대한 단상: Coresspondence(대응), Isomorphism(동형), Equivalence(동치)</title><link href="http://localhost:4000/study/Coressponding/" rel="alternate" type="text/html" title="창의성에 대한 단상: Coresspondence(대응), Isomorphism(동형), Equivalence(동치)" /><published>2022-07-31T00:00:00+00:00</published><updated>2022-07-31T00:00:00+00:00</updated><id>http://localhost:4000/study/Coressponding</id><content type="html" xml:base="http://localhost:4000/study/Coressponding/">&lt;h2 id=&quot;curry-howard-coresspondence&quot;&gt;Curry-Howard Coresspondence&lt;/h2&gt;

&lt;p&gt;타입 이론(type theory) 또는 타입 체계(type system)에 대한 공부를 하다보면, 굉장히 흥미로운 주장이 한 가지 나온다.
바로 커리-하워드 대응인데, 아주 쉽게 얘기해 논리의 증명 연산이 타입 체계와 대응된다는 주장이다.&lt;/p&gt;

&lt;p&gt;개념 정리를 겸하기 위해 조금의 예시를 첨가하자면, 명제 ‘P이면 Q이다’를 기호로 표현한 \(P \rightarrow Q\) (또는 \(P \supset Q\))는 타입 체계에서 function type인 \(P \rightarrow Q\)와 대응, 명제 ‘P이고 Q이다’를 기호로 표현한 \(P \wedge Q\)는 타입 체계에서 pair의 type인 \(P \times Q\)와 대응된다고 할 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;이는 단순히 꼴이 비슷하다 정도가 아니라, 이렇게 대응하였을 때 어떤 명제 P의 증명(proof)이 존재한다는 것을, 그에 대응하는 타입 P에 어떤 값(정확히는 term) t가 존재한다는 것으로 설명 가능하게 된다.&lt;/p&gt;

&lt;p&gt;언뜻 보면 완전히 독립적일 것처럼 보이는 타입 체계와 논리 명제가, 결국 같은 구조를 가지며 같은 이야기를 하고 있을지도 모른다는 것이다!&lt;/p&gt;

&lt;h2 id=&quot;대응-동형-동치&quot;&gt;대응, 동형, 동치&lt;/h2&gt;

&lt;p&gt;커리-하워드 대응은 커리-하워드 동형(isomorphism), 동치(equivalence) 등으로 표현되기도 한다.
독립적으로 보이는 두 체계가 서로 대응되며 각자의 언어로 기술되어 쌓여 온 것들이 통일되는 순간을 표현하기에 적절한 단어들이 아닌가 한다.&lt;/p&gt;

&lt;p&gt;오래 전부터 이런 성격의 발견에 굉장한 흥미와 동경을 품고 있었다.
이를테면 제타 함수(엄밀히는 확장된 리만 제타 함수)와 수소의 분포 사이의 관계에 대한 가설인 리만 가설이라든가, 어떤 잘 정의된 계산 문제(well-defined computational problem)를 다른 형태의(일반적으로 더 넓은 형태의) 문제로 환원(reduce)하는 모든 과정 같은 것들 말이다.&lt;/p&gt;

&lt;p&gt;아주 보잘것 없는 경험이지만, 어릴 적 꽤나 비슷한 형태의 발견을 스스로 해낸 기억이 있다.
너무 오래 전이라 명확하고 구체적인 것은 다 잊었지만, 대략 중고등 물리학을 배울 때 여러 요소들이 가지고 있는 자체적인 성질(이를 \(k_1, k_2\)라는 수치로 나타낼 수 있다 하자)과 각 요소들 사이의 관계(이를 \(m:n\)이라는 실수 비로 나타낼 수 있다 하자)를 값으로 표현하였을 때, 그 요소들이 섞이며 나타나게 되는 최종 성질이 \(k_1 \cdot n + k_2 \cdot m\)와 같은 형태로 표현 가능하다는 것을 배운 적이 있다.
이 식을 보고 바로 무게중심(질량중심)을 구하는 식이 떠올랐고, 이를 가르치던 선생님이 떠오르는 게 없냐 물으셨을 때 무게중심을 이야기하니 어떻게 알았냐며 놀라며 둘의 관계에 대해 설명하시던 소소한 추억이 있다.
그 때 당시에는 그저 참신한 비유나 말장난에 취미가 있던 터라 뜬금없는 맥락의 개념을 어떻게든 끌고 오는 것에 혈안이 되어 있기에 우연히 맞아 떨어진 게 아닌가 하고 넘어갔지만, 그것이 학술적으로 의미를 가질 수 있다는 것이 꽤나 충격이었다.&lt;/p&gt;

&lt;h2 id=&quot;창의성과-과학적-발견&quot;&gt;창의성과 과학적 발견&lt;/h2&gt;

&lt;p&gt;연구자의 길에 막 들어서려는, 이제 조금씩 발부터 담그고 있는 지금 생각해 보면 내가 경험했던 바로 그 경험이 결국 창의라는 것이고 연구의 키 아이디어가 되는 발견이 아닌가 한다.
새로운 패러다임을 여는 과학적 발견은, 대부분의 경우 그 사람이 생각할 수 없었던 말도 안 되게 새로운 개념이 어디선가 튀어나오는 게 아니라 이미 그 사람이 사유하고 있던 추상화된 구조들이 재결합하고 재발견되며 자리를 찾아간 결과이다.&lt;/p&gt;

&lt;p&gt;요하네스 케플러는 물리천문학의 기본이 되는 여러 법칙을 찾아냈다.
지금이야 하늘에 천구라는 것은 없고, 넓디 넓은 우주가 펼쳐져 있다는 것이 상식처럼 받아들여지고 있지만, 케플러가 천체에 대한 탐구를 하던 때만 해도 천구가 당연시되었고, 케플러 역시 하늘과 하늘에 보이는 여러 별들(정확히는 행성들)이 존재하는 형태를 여러 정다면체들로 설명하려 했다.
이후 다양한 탐구적 고비를 겪고, 튀코 브라헤의 정밀하고 방대한 관측 자료를 수학적으로 철저히 분석한 끝에 조화의 법칙과 같은 지금까지도 받아들여지고 확장되는, 과장하면 진리에 가까운 법칙을 발견해냈다.
그가 처음 정다면체로 천구를 설명하려 했던 것은, 당시 그가 기하학에 빠져 있었기 때문에 어떤 현상을 설명하고자 할 때 본인의 머리 대부분을 차지하고 있는 기하학의 언어로써 설명하려는 시도 끝에 나타나게 된 결과이다.
그리고 결국 시대를 관통하는 법칙을 찾아낸 것 역시, 그에게 주어진 (튀코의) 관측 자료를 그 누구보다 깊고 정밀하게 다루어 그가 좋아하던 수학의 언어로 표현하고자 하는 노력을 통해 일궈냈다 할 수 있다.
그의 머릿속을 전부 들여다보지 못하는 우리는 꽤 많은 탐구 과정을 생략하고 ‘새로운’ 발견이라 생각하곤 한다.
그리고 그것이 곧 창의성의 발현이 아닐까.&lt;/p&gt;

&lt;p&gt;창의성의 발현이 과학적 발견으로 이어지는 사례는 이외에도 너무나도 많다.
옥수수 과학자 바바라 매클린톡의 사례는 그의 전기책 [생명의 느낌]을 통해 꽤나 유명해졌는데, 그가 평생 옥수수를 관찰하고 연구하며 발견한 수많은 생물학적 업적들은 그의 표현대로 “자신이 그 생명체가 된다는 느낌”을 받을 때 이루어냈다고 한다.
말 그대로 몰아일체의 경지에 도달한 순간, 머릿속 어딘가에 있던 추상적인 개념들이 정답을 속삭이는 것이다.&lt;/p&gt;

&lt;p&gt;위와 같은 사례들처럼 놀라운 과학적 발견을 해내는 과정에는 번뜩이는 관찰력과 뼈를 깎는 노력이 필요할 것이다.
나는 내가 사랑하는 연구 분야에서 얼마나 창의적일 수 있을까.
얼마나 새로운 대응을 이끌어낼 수 있을까.&lt;/p&gt;</content><author><name>Jaeho Kim</name></author><category term="Study" /><category term="TaPL" /><category term="MISC" /><summary type="html">Curry-Howard Coresspondence</summary></entry><entry><title type="html">개념정리: 의미 구조(Semantics)의 표현 방식들</title><link href="http://localhost:4000/study/Semantics/" rel="alternate" type="text/html" title="개념정리: 의미 구조(Semantics)의 표현 방식들" /><published>2022-07-30T00:00:00+00:00</published><updated>2022-07-30T00:00:00+00:00</updated><id>http://localhost:4000/study/Semantics</id><content type="html" xml:base="http://localhost:4000/study/Semantics/">&lt;h2 id=&quot;헷갈리지-않도록&quot;&gt;헷갈리지 않도록&lt;/h2&gt;

&lt;p&gt;PL과 관련된 분야를 공부하고 연구하기 시작한지도 햇수로 4년이 되어가는데, 아직도 간혹가다 헷갈리는 기본 개념들이 있다.
그럴 때마다 한없는 자괴감에 빠지곤 했는데, 차라리 조금의 창피함을 감수하더라도 블로그에 정리해두는 게 앞으로의 공부에 도움되리라 생각해 생각나는 대로 정리하기로 했다.&lt;/p&gt;

&lt;p&gt;기록하고 싶은 개념이 생길 때마다 한 포스트에 업데이트를 할까 생각도 했지만, 이왕 정리하는 김에 주제별로 포스트를 나눠 조금은 상세하고 친절한 설명을 넣는 것이 좋을 거라는 판단에 꾸준히 여러 포스트를 올리기로 했다.&lt;/p&gt;

&lt;h2 id=&quot;semantics&quot;&gt;Semantics&lt;/h2&gt;

&lt;p&gt;프로그래밍 언어에서 의미 구조(semantics)란 거의 모든 PL 연구의 처음과 끝을 관통하는 개념이라 봐도 무방하지 않을까 싶을 정도로 중요한 존재이기 때문에, 사실 크게 헷갈릴 수 없는 개념이다.
다만 이후 정리해 둘 개념들을 위해 아주 간단하게만 설명하도록 하겠다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어의 문법 요소들(보통 term이라 하며, expression 또는 statement를 생각하면 된다)이 연산 과정(evaluation)을 거쳐 어떤 값(value) 또는 상태(state; 여기서 말하는 상태는 variable -&amp;gt; value와 같은 relation을 생각하면 된다)를 가질지에 대한 규칙을 우리는 의미라 한다.
이 때 의미는 엄밀하게 말해 집합으로 정의되며, 현재 주어진 상태(state 혹은 environment)에서 (문법적으로 올바른) 어떤 식(expression) 또는 구문(statement)의 실행 이후 상태는 존재하여 하나로 결정될 수도, 존재하지 않을 수도 있고, 만약 존재한다면 이는 곧 현재 상태, 식(또는 구문), 이후 상태(또는 값)의 순서쌍이 의미 집합에 존재한다는 식으로 정의된다.&lt;/p&gt;

&lt;p&gt;이렇게 집합으로 정의된다는 것은, 곧 귀납정의(inductive definition)의 한 표현방식인 추론규칙(inference rule)으로 의미를 정의하고 서술할 수 있다는 의미이기도 하다.&lt;/p&gt;

&lt;h2 id=&quot;operational-semantics-vs-denotational-semantics-vs-axiomatic-semantics&quot;&gt;Operational Semantics vs Denotational Semantics (vs Axiomatic Semantics)&lt;/h2&gt;

&lt;p&gt;이제 정말 헷갈리기 시작하는, 그러나 헷갈려서는 안 되는 개념들이 등장하기 시작하는데, 동작 의미 구조(operational semantics)와 표시적 의미 구조(denotational semantics), 공리적 의미 구조(axiomatic semantics)이다.
(*주의: 각 용어들의 번역 용례는 &lt;a href=&quot;http://ropas.snu.ac.kr/lib/term/&quot;&gt;ROPAS 홈페이지의 번역 용례&lt;/a&gt;를 참고하긴 하지만, 번역이 너무 장황하거나 해당 페이지에 존재하지 않는 용어의 경우 임의로 번역하였다)
각각에 대해 간단하게 정리해 두겠다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;동작 의미 구조(Operational Semantics):&lt;/strong&gt; 프로그램의 수행 과정, 즉 상태의 변화를 표현하게끔 정의하는 방식의 의미 구조. 현재 상태에서 특정 식 또는 구문을 실행한 뒤 상태가 어떻게 변화할지 정의한다. 가장 단순하고 직관적이므로 프로그래밍 언어의 실행기(interpreter)를 구현할 때 주로 사용된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표시적 의미 구조(Denotational Semantics):&lt;/strong&gt; 프로그램이 수학적으로 어떻게 표현되어 각각의 식과 구문이 어떤 값을 가지게 되는지 엄밀히 정의하는 방식의 의미 구조. 프로그램 분석 분야에서 요약 실행(abstract interpretation) 과정을 수학적으로 정의할 때 필요하다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공리적 의미 구조(Axiomatic Semantics):&lt;/strong&gt; 프로그램 자체의 구체적인 수행 과정이나 의미를 정의하기보단, 그 프로그램이 실행됨으로써 입증될 수 있는 논리 명제를 얻어내게끔 정의되는 의미 구조. 이러한 특징 덕에 프로그램 논증 분야에서 굉장히 중요하게 다뤄지지만, 사실 프로그램을 실행하는 관점에서 쓸모가 있지는 않다. 완전히 같은 개념은 아니지만, Hoare logic을 떠올리면 되겠다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;big-step-vs-small-step-semantics&quot;&gt;Big Step vs Small Step Semantics&lt;/h2&gt;

&lt;p&gt;동작 의미 구조는 프로그램의 수행 과정을 그대로 정의하는 형태이기 때문에, 매우 간편하며 직관적이다.
다만 더 구체적으로 들어가면, 정의 방식이 두 가지로 나뉘게 된다.
큰 걸음 의미 구조(big step semantics)와 작은 걸음 의미 구조(small step semantics)가 바로 그것이다.
이 역시 정리해 보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;큰 걸음 의미 구조(Big Step Semantics):&lt;/strong&gt; 동작 의미 구조에서의 계산 규칙을 한 번에 끝내는 식으로 정의하는 방식. 현재 상태에서 주어진 식 또는 구문의 실행 결과, 더이상 수행할 것이 없는 최종 상태 도는 값이 된다는 것을 한 번에 표현한다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if t1 then t2 else t3&lt;/code&gt;는 계산 결과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 값을 가지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;가 가지게 되는 값, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;값을 가지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3&lt;/code&gt;가 가지게 되는 값을 가질 것이라고 단번에 정의한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작은 걸음 의미 구조(Small Step Semantics):&lt;/strong&gt; 가능한 한 최소한의 계산 과정 하나하나를 계산 규칙으로 정의하는 방식. 큰 걸음으로는 반드시 그 식 또는 구문의 계산 결과에 해당하는 상태 또는 값이 의미구조에 포함되어야 했지만, 작은 걸음에서는 계산 과정에서 새로 도출되는 식 또는 구문이 그 자리를 대체할 수 있다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if t1 then t2 else t3&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;이 가지게 될 값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;에 대해(물론 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;는 boolean 값일 것이다) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if v then t2 else t3&lt;/code&gt;가 된다고 정의하며, 또 추가로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if true then t1 else t2&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;의 값을 가지며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if false then t1 else t2&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;의 값을 가진다는 것을 각각 따로 정의한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Jaeho Kim</name></author><category term="Study" /><category term="Programing Languages" /><category term="TaPL" /><summary type="html">헷갈리지 않도록</summary></entry><entry><title type="html">생애 첫 수업조교</title><link href="http://localhost:4000/records/KLUE/" rel="alternate" type="text/html" title="생애 첫 수업조교" /><published>2022-06-04T00:00:00+00:00</published><updated>2022-06-04T00:00:00+00:00</updated><id>http://localhost:4000/records/KLUE</id><content type="html" xml:base="http://localhost:4000/records/KLUE/">&lt;h2 id=&quot;기록물-1번&quot;&gt;기록물 1번&lt;/h2&gt;

&lt;p&gt;벌써 2년 가까이 지난 일이지만, 개인 홈페이지(겸 블로그)를 만들고 글을 쓰기로 마음먹은 뒤 아직도 서문만 쓰고 글을 쓰지 못하고 있는 나 자신을 위해, 또 아직까지도 꿈을 향하고 있는 내 원동력 벡터의 크기를 유지시켜주는 데 일조하고 있는 과거의 경험을 정리하기 위해 이 포스트를 남긴다.
또 기록하고 싶은 경험 또는 자료가 있을 때마다 아주 짧은 코멘트와 함께 정리해 두고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;첫-수업조교&quot;&gt;첫 수업조교&lt;/h2&gt;

&lt;p&gt;2020년 초여름, &lt;a href=&quot;https://www.korea.ac.kr/mbshome/mbs/university/index.do&quot;&gt;고려대학교&lt;/a&gt; &lt;a href=&quot;http://prl.korea.ac.kr/~pronto/home/&quot;&gt;소프트웨어 분석 연구실&lt;/a&gt;에 인턴을 하고 있을 당시 일이다.
오학주 교수님께서 가을학기에 컴퓨터프로그래밍2(파이썬 기초 강의)를 진행하신다는 이야기를 듣고 바로 수업조교를 해보고 싶다고 말씀드려, 조교로써 수업 준비를 도와 드리게 되었다.
처음엔 꽤나 자신있었지만, 과정은 의외로 고통스러웠으며 결국 여러 사정이 겹쳐 나를 휴학까지 하게 만들었던 활동이다. 그럼에도 즐겁고 행복했던 기억이다.
교수님께서 강의의 방향과 의도를 잡아 주시면 그에 알맞게 과제를 직접 준비하였고 매주 두 번의 수업 중 한 번은 직접 수업을 진행할 수 있는 기회를 갖기도 하였다.
그 과정 하나하나가 생생하고 의미 있었던 것 같다. 그 때의 뿌듯함을 잊지 않도록 여기에 기록물을 올려 두고자 한다.
마음 같아서는 직접 만든 과제 문제들도 함께 올려두고 싶지만 혹시 모를 문제의 발생을 막기 위해 강의평가만 pdf 형식으로 올린다.
이 강의평가들은 언제 읽어도 뿌듯하고 또 나아갈 힘을 얻게 만든다.
물론 크게 좋은 내용만 있는 건 아니다. 수업 내용에 비해 과제가 너무 어렵다든가 하는 그런 내용도 많다…
다만 개인적으로는 어느 정도 의도했기 때문에 이런 반응이 더더욱 즐거웠다.
앞으로 맡게 될 수업조교, 언젠가 맡게 될 수업을 그려보며 또 다시 읽어 보련다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/pdf/KLUE.pdf&quot;&gt;컴퓨터프로그래밍2 강의평가&lt;/a&gt; (고려대학교 강의평가 사이트 KLUE에 올라온 강의평이기 때문에 문제가 발생할 경우 비공개 처리하겠습니다)&lt;/p&gt;</content><author><name>Jaeho Kim</name></author><category term="Records" /><category term="Teaching" /><category term="Course" /><summary type="html">기록물 1번</summary></entry></feed>