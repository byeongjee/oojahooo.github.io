<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-13T09:17:32+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jaeho Kim</title><subtitle>my new homepage</subtitle><author><name>Jaeho Kim</name></author><entry><title type="html">삽질의 즐거움: vim편</title><link href="http://localhost:4000/study/vim/" rel="alternate" type="text/html" title="삽질의 즐거움: vim편" /><published>2022-09-26T00:00:00+00:00</published><updated>2022-10-13T00:00:00+00:00</updated><id>http://localhost:4000/study/vim</id><content type="html" xml:base="http://localhost:4000/study/vim/">&lt;h2 id=&quot;vim&quot;&gt;VIM&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:wq&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:q!&lt;/code&gt;가 그저 힙해보인다는 이유로, 그리고 리눅스를 사용하게 되면 결국 웬만하면 다 설치되어 있고, 그렇지 않더라도 설치하기 쉬운
&lt;a href=&quot;https://www.vim.org&quot;&gt;vim&lt;/a&gt;을 쓰는 게 편하다는 명분으로 입문한지 5년은 더 지난 듯하다. 사실 처음 붙잡고 공부했을 때에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;의 수많은
스크립트들을 이해하고 써먹기는커녕 어찌어찌 친절한 블로거의 예시를 그대로 가져다 쓰며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hjkl&lt;/code&gt;를 비롯한 기본 중의 기본이 되는 키맵들을 익히기에
바빴다. 코딩 공부보다 코딩을 위한 에디터 공부가 더 힘들 지경이었다.&lt;/p&gt;

&lt;p&gt;그 과정을 겪고 나니, 확실히 괜히 있어보이고 또 실제로도 꽤나 생산성 있게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim&lt;/code&gt;으로 코드를 작성할 수 있게 되었다. 그러나, 딱 거기까지였다. 더
제대로 된 기능을 써먹기에는 내 능력이 부족했고, 그저 평범한 에디터에서는 잘 쓰이지도 않는 구닥다리 키맵이 손에 익어버려 다른 에디터 쓸 때 헷갈리기나
하는 신세가 되어버렸다. 그렇게 그 당시 내 나름의 능력치 안에서 픽스드포인트에 도달해버리니, 굳이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim&lt;/code&gt;을 그대로 써먹어야 할 필요가 있나 싶어
다른 에디터를 사용하기 시작했다. 얼마 지나지 않아 정착한 것이 &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;vs code&lt;/a&gt;였다. 물론 에디터를 옮긴 뒤에도
손에 익은 습관은 버리지 못해, vs code에 vim extension을 설치해 최소한의 키맵과 모드들은 사용할 수 있도록 하여 오묘한 시너지 효과를 즐기는
편이었다.&lt;/p&gt;

&lt;p&gt;그렇게 vs code로 정착한지도 꽤 되었는데, 갑자기 오늘 vim을 사용하고 싶어졌다. 정확히는 vs code에 이미 있음에도 단축키가 익지 않아 잘
쓰지 않던 기능들이, 오히려 vim에서 빠르게 사용 가능하다는 것을 알게 되어 다시 한 번 제대로 세팅해보고 싶어진 것이다.&lt;/p&gt;

&lt;p&gt;그렇게 또다시 삽질이 시작됐다.&lt;/p&gt;

&lt;h2 id=&quot;neovim&quot;&gt;NEOVIM&lt;/h2&gt;
&lt;p&gt;이번에는, 지난번에 그냥 블로거가 좋다길래 아무 생각 없이 설치하고 사용했던 &lt;a href=&quot;https://neovim.io&quot;&gt;neovim&lt;/a&gt;을 사용해 세팅을 마무리하기로 하였다.
Neovim만의 여러 장점이 있다고 하는데, 사실 아직도 잘 모르겠다. 그냥 요즘 플러그인들은 neovim을 많이들 타겟팅하고 있어 보였고, vim에서 될만한
웬만한 것들은 neovim에서도 되기에 그렇게 결정하였다.&lt;/p&gt;

&lt;p&gt;Neovim은 다음과 같이 간단하게 설치 가능하다:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install neovim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;간혹 최신 릴리즈가 설치되지 않는 경우도 있는데, 최신 릴리즈가 꼭 필요하다 싶으면 neovim의 깃허브 레포에 있는 &lt;a href=&quot;https://github.com/neovim/neovim/releases/latest&quot;&gt;최신 릴리즈&lt;/a&gt;
버전을 다운받은 뒤 설치하면 된다. 현재 최신 버전인 0.7.2버전으로 예를 들면, 다음과 같이 진행하면 된다:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/neovim/neovim/releases/download/v0.7.2/nvim-linux64.deb
sudo apt install ./nvim-linux64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(*주의: 이미 위의 방식으로 neovim을 설치한 적 있다면, 여러 dependency 때문에 아래 방식으로 설치할 때 문제가 생길 수 있다. 다 깨끗하게 지우고 시도하자)&lt;/p&gt;

&lt;p&gt;Neovim 설치가 끝났다면, 다음의 작업도 수행해 neovim의 여러 파이썬을 활용하는 기능들을 문제없이 사용할 수 있도록 하자:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install neovim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(*당연히 python 및 pip은 진작 설치되어 있어야 한다)&lt;/p&gt;

&lt;p&gt;나 같은 경우는, 추가로 본인의 쉘 프로파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.bash_profile&lt;/code&gt;, etc.)에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alias vi='nvim'&lt;/code&gt;을 추가하여 로그인시
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vi&lt;/code&gt; 커맨드를 실행했을 때 자연스럽게 neovim이 실행되도록 하였다.&lt;/p&gt;

&lt;h2 id=&quot;vimrc-colors-vim-plug&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;, colors, vim-plug&lt;/h2&gt;
&lt;p&gt;이제 vim을 내 입맛대로 고쳐야 할 시간이다. 아무래도 새로운 컴퓨터에서 세팅을 해야 하거나 새로운 서버에도 정성껏 나의 세팅대로 vim을 사용하고
싶었기 때문에 나만의 세팅을 내 &lt;a href=&quot;https://github.com/oojahooo/vim-setup&quot;&gt;깃허브 레포&lt;/a&gt;로 올려 두었다. Vim을 쓰다 nvim으로 옮기면 몇가지
디렉토리 세팅도 다시 해줘야 하기에, 차근차근히 순서대로 기록해 두고자 한다.&lt;/p&gt;

&lt;p&gt;가장 먼저 알아둬야 할 것은, neovim 환경설정을 위한 디렉토리 구조이다. Neovim은 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.config/nvim/&lt;/code&gt; 디렉토리 아래에 여러 세팅용 파일 및
디렉토리들을 담아둔다. 이는 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vim&lt;/code&gt; 디렉토리에 플러그인과 컬러테마들을 저장해 두고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vimrc&lt;/code&gt;로 여러 설정을 하던 vim과는 조금 다른 구조이다.
그래서 일단 기존의 vim을 세팅하던 때와 같은 환경에서 자연스럽게 neovim 세팅을 하기 위해, neovim의 설정파일 경로인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.config/nvim/init.vim&lt;/code&gt;을
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vimrc&lt;/code&gt;로 링크 걸어두고, 컬러테마 폴더 경로인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.config/nvim/colors/&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vim/colors/&lt;/code&gt;로 링크 걸어뒀다. 굳이 이렇게 할 필요는
없는 걸로 알기에, 해당 부분은 재량껏 넘어가도 좋다.
(*주의: 당연히 원본 파일들이 있어야 문제없이 링크가 된다. 나는 이미 숱한 삽질 끝에 어느정도 안정적인 세팅을 &lt;a href=&quot;https://github.com/oojahooo/vim-setup&quot;&gt;깃허브 레포&lt;/a&gt;에
담아두었기에 여기 있는 파일들을 먼저 홈 디렉토리에 경로에 맞게 옮겨준 뒤 링크를 걸어준다)&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ln -s ~/.config/nvim/init.vim ~/.vimrc
mkdir .vim
ln -s ~/.config/nvim/colors ~/.vim/colors
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;*주의: 어쩔 수 없이, 세팅 과정이 많이 꼬여있다. 원래 정석대로라면 무언가 필요한 패키지나 바이너리들을 먼저 설치하고 그에 맞춰 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;를 수정해야
하는데, 한 번 세팅한 채로 쭉 써먹기 위해서는 그런 과정이 무시될 수밖에 없다. 그렇기에 중간중간 커맨드 에러가 나더라도 무시하고 아래 적힌 순서대로만
따라하면 큰 문제가 없게 완료되도록 기록을 해 두겠다.&lt;/p&gt;

&lt;p&gt;참고로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;에서 해둔 세팅이 뭔지를 알아야 다음 단계가 이해되기 때문에, 간단하게 정리해 두겠다. 세팅은 크게 다음과 같이 나눠진다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;아주 기본적인 세팅 (기존의 vi 환경을 사용할지, 탭은 어떻게 쓸지, 들여쓰기는 어쩔지, 라인넘버는 어떻게 표시할지 등등)&lt;/li&gt;
  &lt;li&gt;유용한 키맵들 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;leader&amp;gt;&lt;/code&gt; 키 설정 및 플러그인과 관계 없이 적용할 여러 키맵들)&lt;/li&gt;
  &lt;li&gt;플러그인들 (vim-plug 사용)&lt;/li&gt;
  &lt;li&gt;각종 플러그인들에 대한 세부 세팅들&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아무래도 누군가 나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;를 가져다 쓴다면, 2번까지는 일단 복붙해서 쓰더라도, 3번부터는 본인 입맛에 맞게 취사선택하는 게 좋을 것이다.
(*아래에서도 주기적으로 강조하겠지만, 안 그러면 에러 투성이의 vim을 맛보게 될 것이다. 예를 들어, 4번 항목에서 OPAM 및 OCaml 사용을 위해 opam
user-setup을 통해 자동으로 추가한 여러 스크립트들이 포함되어 있는데, 이는 OPAM의 버전이 2.1일 때 제대로 돌아가질 않는다. 그래서 어쩔 수 없이
본인의 쉘 프로파일에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export OPAMCLI=2.0&lt;/code&gt;을 추가해 줘야 문제가 안 생기는데, 이를 알아내는 과정도 그리 순탄치는 않았다.)&lt;/p&gt;

&lt;p&gt;이제 다음 단계이다. 여기까지만 와도 사람처럼 쓸 수 있는 에디터가 되지만, 사실 요즘의 빵빵한 에디터들 사이에서 경쟁력을 가지기 위해서는 아직 여러모로
부족하다. 코드 자동완성이라든가, 린터나 포매터 같은 것들을 사용하기 위해서는 플러그인이 필요하다.&lt;/p&gt;

&lt;p&gt;가장 먼저(뒤에서 설치할 어떤 플러그인 때문에), 최신 버전의 node.js가 필요하다. 알아서 잘 설치하면 되는데, 웬만하면 &lt;a href=&quot;https://github.com/nvm-sh/nvm&quot;&gt;nvm&lt;/a&gt;을
이용하도록 하자. 아마 위 링크를 들어가 보면 설치 및 사용 방법이 매우매우 친절하게 나와 있기 때문에, 굳이 여기에 다시 적어두진 않겠다. 무언가
업데이트 되면서 커맨드가 바뀔 수도 있지 않은가.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;의 중간에 예쁜 컬러테마를 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;colo zenburn&lt;/code&gt;을 추가해 뒀는데, 이를 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.config/nvim/colors&lt;/code&gt; (또는 링크한
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vim/colors&lt;/code&gt;) 디렉토리 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zenburn.vim&lt;/code&gt; 파일이 있어야만 한다. 나는 &lt;a href=&quot;https://github.com/jnurmine/Zenburn&quot;&gt;이 링크&lt;/a&gt;에서 받아서
넣어줬다.&lt;/p&gt;

&lt;p&gt;이제 정말 플러그인을 설치해 보도록 하자. 나 같은 경우에는 &lt;a href=&quot;https://github.com/junegunn/vim-plug&quot;&gt;vim-plug&lt;/a&gt;를 사용한다. 개인적으로 가장
쉽고 간편하게 플러그인 관리가 가능하며, 대부분의 유명한 플러그인들은 vim-plug로 플러그인을 설치할 수 있도록 제공해주고 있기 때문이다. 이를
사용하기 위해, 따로 설치를 해줘야 한다. 아마 위 링크를 들어가 보면 매우매우 친절하게 나와 있기 때문에, 굳이 여기에 다시 적어두진 않겠다. 무언가
업데이트 되면서 커맨드가 바뀔 수도 있지 않은가.&lt;/p&gt;

&lt;p&gt;위를 설치한 뒤에, 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vi ~/.vimrc&lt;/code&gt;를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;를 열어보자. 사실 아무 파일이나 열어도 되긴 하지만, 세팅을 확인하면서 플러그인을 설치하면
좋으니까 같이 열어서 보자. nvim이 열린 상태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:PlugInstall&lt;/code&gt;을 입력하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call plug#begin('~/.vim/plugged')&lt;/code&gt; 아래부터
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call plug#end()&lt;/code&gt; 위까지 적혀있는 플러그인 목록들이 쭉 설치된다. 눈치가 빠르다면 보이겠지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vim/plugged/&lt;/code&gt; 디렉토리에 플러그인들을
설치하기 때문에 기존 vim 사용자들도 자연스럽게 사용 가능하며, 혹시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.vim&lt;/code&gt; 디렉토리를 굳이 따로 만들고 싶지 않다면 해당 부분의 경로를 바꿔주면
될 것이다.&lt;/p&gt;

&lt;p&gt;아마 웬만하면 문제없이 모든 플러그인이 빠르게 설치될 것이다. 이후 vim을 종료했다가 다시 열면 플러그인이 적용된 상태라고 보면 된다.&lt;/p&gt;

&lt;p&gt;이제 정말 중요하고도 어려운 설정이 남았는데, 바로 &lt;a href=&quot;https://github.com/neoclide/coc.nvim&quot;&gt;coc.nvim&lt;/a&gt;이다. 조금 전 vim-plug를 통해 잘
설치가 되었을 거라 기대하는데, 사실 내 vim-setup에서 바로 파일을 복붙했다면 지금까지의 과정에서 vim을 새로 열 때마다 커맨드 에러가 떠서 애를
먹었을 것이다. 그러니까 막 복붙하지 말고 차근차근히 해야 무탈한 것이다. 물론 커맨드 에러는 무시하면 되므로 내가 새로운 컴퓨터에 세팅할 때에는
그냥 복붙한다. 또한 node.js를 설치해야 하는 이유도 이 coc.nvim 때문이기에, &lt;strong&gt;반드시 순서를 지켜&lt;/strong&gt; node.js를 설치한 후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:PlugInstall&lt;/code&gt;을
해줘 coc.nvim 설치 과정에 문제가 없도록 하자.&lt;/p&gt;

&lt;p&gt;아무튼 coc.nvim 플러그인 자체는 이미 설치가 완료되었을텐데, 이를 진짜 제대로 사용하기 위해서는 아주 복잡해 보이는 세팅 스크립트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;에
추가해야 하며, 또 여러 필요한 coc extension들을 설치해 줘야 한다. 일단 coc.nvim에서 설치하라고 권장하는 coc-json과 coc-tsserver를 설치해
주도록 하자. Neovim을 열어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:CocInstall coc-json coc-tsserver&lt;/code&gt;를 입력하면 설치가 진행된다. 추가로 필요한 extension들을 찾아서 설치하면
되는데, 나는 주로 OCaml, Python, C/C++을 다루기 때문에 coc-pyright, coc-clangd를 더 설치해 주고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:CocConfig&lt;/code&gt; 커맨드를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coc-settins.json&lt;/code&gt;
파일을 다음과 같이 수정해 줬다:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;languageserver&quot;: {
        &quot;ocaml-lsp&quot;: {
            &quot;command&quot;: &quot;opam&quot;,
            &quot;args&quot;: [&quot;config&quot;, &quot;exec&quot;, &quot;--&quot;, &quot;ocamllsp&quot;],
            &quot;filetypes&quot;: [&quot;ocaml&quot;, &quot;reason&quot;]
        }
    },
    &quot;coc.preferences.currentFunctionSymbolAutoUpdate&quot;: true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;추가-copilot&quot;&gt;(추가) Copilot&lt;/h3&gt;

&lt;p&gt;Copilot이 상용화되면서, 친절한 GitHub는 neovim에서 copilot을 사용할 수 있도록 플러그인을 제공해 주었다. 세팅도 매우매우 간단한데, 몇가지
메모사항이 있어 추가한다. 참고로 내 경우에는 &lt;a href=&quot;https://education.github.com/&quot;&gt;GitHub Education&lt;/a&gt;에서 학생 인증을 통해 student pack을
제공받아 copilot을 사용중이다.&lt;/p&gt;

&lt;p&gt;Copilot 서비스를 제공받기 위한 과정은 알아서 개인적으로 했다 치고, copilot을 사용 가능한(구독중인) GitHub 계정이 준비되어 있다고 하자.
이제 neovim에서 이를 사용하기 위해서는 플러그인을 추가해야 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt; 파일을 열어 지금까지 플러그인을 추가했던 방법대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;github/copilot&lt;/code&gt;
플러그인을 추가하면 된다. 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plug 'github/copilot.vim'&lt;/code&gt; 한 줄만 추가해 주면 된다. 당연히 내 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;에는 추가해 뒀다.&lt;/p&gt;

&lt;p&gt;그 뒤에 vim을 연 뒤 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:Copilot setup&lt;/code&gt; 커맨드만 입력하면 된다. 이 때 계정 연동 및 인증을 위해 인증 코드를 띄워주고 엔터를 입력하면 브라우저를
통해 인증 페이지를 열기 시도한다. 만약 리눅스 서버 등의 환경에서 작업하는 중이라면 브라우저를 열지 못해 실패 메시지가 뜰텐데, 당황하지 말고
이 때 뜨는 링크로 직접 브라우저를 열어 접속한 뒤, 인증 코드를 입력해 인증해 주면 된다.&lt;/p&gt;

&lt;p&gt;사실 이것만으로 copilot을 사용하기 위한 준비는 끝났다. 바로 아무 파일이나 열어 코드(아니면 논문이라도)를 작성해 보자. 대충 입력한 뒤 적당히
커서를 두고 입력을 하다가 말면, 입력하던 부분에 이어서 회색 텍스트가 뜰 것이다. Copilot의 추천 텍스트이다. 만약 다른 세팅을 건드리지 않았다면,
여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;tab&amp;gt;&lt;/code&gt;을 입력하면 추천해준 텍스트가 실제로 적용되어 입력될 것이다. 만약 같은 상황에서 추천 후보를 더 보고 싶다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;M-]&amp;gt;&lt;/code&gt;를, 다시 이전
추천으로 돌아가고 싶다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;M-[&amp;gt;&lt;/code&gt;를 입력하면 된다. 그런데 개인적으로 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;tab&amp;gt;&lt;/code&gt;을 다른 auto completion 플러그인에 적용하여 사용중인데,
둘 다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;tab&amp;gt;&lt;/code&gt;으로 두고 쓰자니 오히려 불편해지는 감도 있고, (물론 copilot의 주장으로는 단축키 겹침으로 인한 불편함을 최소화하기 위해 추천하지
않을 때에는 기능대체가 되게끔 한다고 한다) 메타 키(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt&lt;/code&gt; 키)를 거의 사용하지 않는 편이라 다른 단축키들도 손에 잘 익지 않아 키맵을 바꿔 주었다.
사실 같은 상황에서 copilot의 여러 추천을 볼 수 있다는 것도 이 키맵 설정을 위해 이것저것 찾아보다 알게 된 기능이라, 의도치 않게 큰 이득을 봤다.
아무튼 원하는 새 키맵 역시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;에 추가해 주면, copilot 설정은 진짜로 끝이다.&lt;/p&gt;

&lt;h2 id=&quot;아마-끝&quot;&gt;아마 끝?&lt;/h2&gt;

&lt;p&gt;여기까지 왔으면, 아마 높은 확률로 아무 커맨드 에러 없이 아주 예쁘고 강력한 vim을 사용할 수 있을 것이다. 이를 완성하는 데 정말 많은 삽질을 했으나,
처음 이 포스트를 쓰기 시작할 때만 해도 그저 설움을 토로하기 위함이었는데 쓰다보니 준 튜토리얼급의 글을 적어버려 삽질 과정은 많이 생략하여 서술했다.
그래도 한 가지 꼭 기억해둘 삽질이 있기에 첨언해 두자면, coc.nvim의 핵심 기능 중 여러 경고 및 에러 메시지를 띄워주는 diagnostics를 포함하여
여러 리스트 창을 띄우는 기능들이 있는데, 이게 이상하게 원래 의도대로라면 작은 창으로 아래쪽에 떠서 esc만 눌러도 사라져야 하는데, 나 같은 경우
기존 버퍼를 다 덮어씌워 버려 끄지도 못하고 나가려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:q!&lt;/code&gt;를 해야 하는 문제가 있었다. 원인을 찾기 위해 온갖 키워드(e.g. coc + diagnostics + fuzzy + …)들
을 넣어가며 구글링해보다가, 뭔가 다른 플러그인과의 충돌인 것 같아 길고 긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;에서 각 설정 뭉치들을 주석하고, 주석을 풀어가며 기능이 언제
잘 작동하고 망가지는지 비교해 보는 짓을 해야만 했다. 그리고 찾은 원인은 &lt;strong&gt;NERDTree&lt;/strong&gt;라는 플러그인. Neovim에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:vs&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:bo vs&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:sp&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:bo sp&lt;/code&gt;
커맨드를 조금 더 스마트하게 사용하기 위해 거의 필수로 설치하고 설정해 두는 플러그인인데, 이 플러그인이 새로 열리는 임시 버퍼의 화면비크기를 마음대로
고정해 버리는 부분이 아마 문제였던 것 같다. 물론 조금만 더 잘 찾아보면 NERDTree와 coc.nvim을 함께 잘 사용할 방법이 있겠지만, 솔직히 이제는
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:vs&lt;/code&gt; 커맨드를 쓰는 게 더 익숙해졌기에 미련없이 NERDTree 플러그인과 관련 설정 스크립트를 지워버렸다. 이젠 문제 없겠지.&lt;/p&gt;

&lt;h2 id=&quot;새로운-시작&quot;&gt;새로운 시작&lt;/h2&gt;
&lt;p&gt;그렇게 해서 어찌저찌, 이번에는 정말 스크립트를 이해한 상태에서 여러 플러그인을 설치하고 세팅을 입맛대로 바꿔 보았다. 정말 많은 삽질과 고난이
있었지만, 대부분 마음 속에만 묻어 두기로 하고 나름 깔끔하게 포스트로 기록해 보았다. Vim아~ 이제 내 속 썩이지 말고 나랑 같이 오래오래 행복해야 한다~&lt;/p&gt;</content><author><name>Jaeho Kim</name></author><category term="Study" /><category term="vim" /><category term="editor" /><summary type="html">VIM</summary></entry><entry><title type="html">창의성에 대한 단상: Coresspondence(대응), Isomorphism(동형), Equivalence(동치)</title><link href="http://localhost:4000/study/Coressponding/" rel="alternate" type="text/html" title="창의성에 대한 단상: Coresspondence(대응), Isomorphism(동형), Equivalence(동치)" /><published>2022-07-31T00:00:00+00:00</published><updated>2022-07-31T00:00:00+00:00</updated><id>http://localhost:4000/study/Coressponding</id><content type="html" xml:base="http://localhost:4000/study/Coressponding/">&lt;h2 id=&quot;curry-howard-coresspondence&quot;&gt;Curry-Howard Coresspondence&lt;/h2&gt;

&lt;p&gt;타입 이론(type theory) 또는 타입 체계(type system)에 대한 공부를 하다보면, 굉장히 흥미로운 주장이 한 가지 나온다.
바로 커리-하워드 대응인데, 아주 쉽게 얘기해 논리의 증명 연산이 타입 체계와 대응된다는 주장이다.&lt;/p&gt;

&lt;p&gt;개념 정리를 겸하기 위해 조금의 예시를 첨가하자면, 명제 ‘P이면 Q이다’를 기호로 표현한 \(P \rightarrow Q\) (또는 \(P \supset Q\))는 타입 체계에서 function type인 \(P \rightarrow Q\)와 대응, 명제 ‘P이고 Q이다’를 기호로 표현한 \(P \wedge Q\)는 타입 체계에서 pair의 type인 \(P \times Q\)와 대응된다고 할 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;이는 단순히 꼴이 비슷하다 정도가 아니라, 이렇게 대응하였을 때 어떤 명제 P의 증명(proof)이 존재한다는 것을, 그에 대응하는 타입 P에 어떤 값(정확히는 term) t가 존재한다는 것으로 설명 가능하게 된다.&lt;/p&gt;

&lt;p&gt;언뜻 보면 완전히 독립적일 것처럼 보이는 타입 체계와 논리 명제가, 결국 같은 구조를 가지며 같은 이야기를 하고 있을지도 모른다는 것이다!&lt;/p&gt;

&lt;h2 id=&quot;대응-동형-동치&quot;&gt;대응, 동형, 동치&lt;/h2&gt;

&lt;p&gt;커리-하워드 대응은 커리-하워드 동형(isomorphism), 동치(equivalence) 등으로 표현되기도 한다.
독립적으로 보이는 두 체계가 서로 대응되며 각자의 언어로 기술되어 쌓여 온 것들이 통일되는 순간을 표현하기에 적절한 단어들이 아닌가 한다.&lt;/p&gt;

&lt;p&gt;오래 전부터 이런 성격의 발견에 굉장한 흥미와 동경을 품고 있었다.
이를테면 제타 함수(엄밀히는 확장된 리만 제타 함수)와 수소의 분포 사이의 관계에 대한 가설인 리만 가설이라든가, 어떤 잘 정의된 계산 문제(well-defined computational problem)를 다른 형태의(일반적으로 더 넓은 형태의) 문제로 환원(reduce)하는 모든 과정 같은 것들 말이다.&lt;/p&gt;

&lt;p&gt;아주 보잘것 없는 경험이지만, 어릴 적 꽤나 비슷한 형태의 발견을 스스로 해낸 기억이 있다.
너무 오래 전이라 명확하고 구체적인 것은 다 잊었지만, 대략 중고등 물리학을 배울 때 여러 요소들이 가지고 있는 자체적인 성질(이를 \(k_1, k_2\)라는 수치로 나타낼 수 있다 하자)과 각 요소들 사이의 관계(이를 \(m:n\)이라는 실수 비로 나타낼 수 있다 하자)를 값으로 표현하였을 때, 그 요소들이 섞이며 나타나게 되는 최종 성질이 \(k_1 \cdot n + k_2 \cdot m\)와 같은 형태로 표현 가능하다는 것을 배운 적이 있다.
이 식을 보고 바로 무게중심(질량중심)을 구하는 식이 떠올랐고, 이를 가르치던 선생님이 떠오르는 게 없냐 물으셨을 때 무게중심을 이야기하니 어떻게 알았냐며 놀라며 둘의 관계에 대해 설명하시던 소소한 추억이 있다.
그 때 당시에는 그저 참신한 비유나 말장난에 취미가 있던 터라 뜬금없는 맥락의 개념을 어떻게든 끌고 오는 것에 혈안이 되어 있기에 우연히 맞아 떨어진 게 아닌가 하고 넘어갔지만, 그것이 학술적으로 의미를 가질 수 있다는 것이 꽤나 충격이었다.&lt;/p&gt;

&lt;h2 id=&quot;창의성과-과학적-발견&quot;&gt;창의성과 과학적 발견&lt;/h2&gt;

&lt;p&gt;연구자의 길에 막 들어서려는, 이제 조금씩 발부터 담그고 있는 지금 생각해 보면 내가 경험했던 바로 그 경험이 결국 창의라는 것이고 연구의 키 아이디어가 되는 발견이 아닌가 한다.
새로운 패러다임을 여는 과학적 발견은, 대부분의 경우 그 사람이 생각할 수 없었던 말도 안 되게 새로운 개념이 어디선가 튀어나오는 게 아니라 이미 그 사람이 사유하고 있던 추상화된 구조들이 재결합하고 재발견되며 자리를 찾아간 결과이다.&lt;/p&gt;

&lt;p&gt;요하네스 케플러는 물리천문학의 기본이 되는 여러 법칙을 찾아냈다.
지금이야 하늘에 천구라는 것은 없고, 넓디 넓은 우주가 펼쳐져 있다는 것이 상식처럼 받아들여지고 있지만, 케플러가 천체에 대한 탐구를 하던 때만 해도 천구가 당연시되었고, 케플러 역시 하늘과 하늘에 보이는 여러 별들(정확히는 행성들)이 존재하는 형태를 여러 정다면체들로 설명하려 했다.
이후 다양한 탐구적 고비를 겪고, 튀코 브라헤의 정밀하고 방대한 관측 자료를 수학적으로 철저히 분석한 끝에 조화의 법칙과 같은 지금까지도 받아들여지고 확장되는, 과장하면 진리에 가까운 법칙을 발견해냈다.
그가 처음 정다면체로 천구를 설명하려 했던 것은, 당시 그가 기하학에 빠져 있었기 때문에 어떤 현상을 설명하고자 할 때 본인의 머리 대부분을 차지하고 있는 기하학의 언어로써 설명하려는 시도 끝에 나타나게 된 결과이다.
그리고 결국 시대를 관통하는 법칙을 찾아낸 것 역시, 그에게 주어진 (튀코의) 관측 자료를 그 누구보다 깊고 정밀하게 다루어 그가 좋아하던 수학의 언어로 표현하고자 하는 노력을 통해 일궈냈다 할 수 있다.
그의 머릿속을 전부 들여다보지 못하는 우리는 꽤 많은 탐구 과정을 생략하고 ‘새로운’ 발견이라 생각하곤 한다.
그리고 그것이 곧 창의성의 발현이 아닐까.&lt;/p&gt;

&lt;p&gt;창의성의 발현이 과학적 발견으로 이어지는 사례는 이외에도 너무나도 많다.
옥수수 과학자 바바라 매클린톡의 사례는 그의 전기책 [생명의 느낌]을 통해 꽤나 유명해졌는데, 그가 평생 옥수수를 관찰하고 연구하며 발견한 수많은 생물학적 업적들은 그의 표현대로 “자신이 그 생명체가 된다는 느낌”을 받을 때 이루어냈다고 한다.
말 그대로 몰아일체의 경지에 도달한 순간, 머릿속 어딘가에 있던 추상적인 개념들이 정답을 속삭이는 것이다.&lt;/p&gt;

&lt;p&gt;위와 같은 사례들처럼 놀라운 과학적 발견을 해내는 과정에는 번뜩이는 관찰력과 뼈를 깎는 노력이 필요할 것이다.
나는 내가 사랑하는 연구 분야에서 얼마나 창의적일 수 있을까.
얼마나 새로운 대응을 이끌어낼 수 있을까.&lt;/p&gt;</content><author><name>Jaeho Kim</name></author><category term="Study" /><category term="TaPL" /><category term="MISC" /><summary type="html">Curry-Howard Coresspondence</summary></entry><entry><title type="html">개념정리: 의미 구조(Semantics)의 표현 방식들</title><link href="http://localhost:4000/study/Semantics/" rel="alternate" type="text/html" title="개념정리: 의미 구조(Semantics)의 표현 방식들" /><published>2022-07-30T00:00:00+00:00</published><updated>2022-07-30T00:00:00+00:00</updated><id>http://localhost:4000/study/Semantics</id><content type="html" xml:base="http://localhost:4000/study/Semantics/">&lt;h2 id=&quot;헷갈리지-않도록&quot;&gt;헷갈리지 않도록&lt;/h2&gt;

&lt;p&gt;PL과 관련된 분야를 공부하고 연구하기 시작한지도 햇수로 4년이 되어가는데, 아직도 간혹가다 헷갈리는 기본 개념들이 있다.
그럴 때마다 한없는 자괴감에 빠지곤 했는데, 차라리 조금의 창피함을 감수하더라도 블로그에 정리해두는 게 앞으로의 공부에 도움되리라 생각해 생각나는 대로 정리하기로 했다.&lt;/p&gt;

&lt;p&gt;기록하고 싶은 개념이 생길 때마다 한 포스트에 업데이트를 할까 생각도 했지만, 이왕 정리하는 김에 주제별로 포스트를 나눠 조금은 상세하고 친절한 설명을 넣는 것이 좋을 거라는 판단에 꾸준히 여러 포스트를 올리기로 했다.&lt;/p&gt;

&lt;h2 id=&quot;semantics&quot;&gt;Semantics&lt;/h2&gt;

&lt;p&gt;프로그래밍 언어에서 의미 구조(semantics)란 거의 모든 PL 연구의 처음과 끝을 관통하는 개념이라 봐도 무방하지 않을까 싶을 정도로 중요한 존재이기 때문에, 사실 크게 헷갈릴 수 없는 개념이다.
다만 이후 정리해 둘 개념들을 위해 아주 간단하게만 설명하도록 하겠다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어의 문법 요소들(보통 term이라 하며, expression 또는 statement를 생각하면 된다)이 연산 과정(evaluation)을 거쳐 어떤 값(value) 또는 상태(state; 여기서 말하는 상태는 variable -&amp;gt; value와 같은 relation을 생각하면 된다)를 가질지에 대한 규칙을 우리는 의미라 한다.
이 때 의미는 엄밀하게 말해 집합으로 정의되며, 현재 주어진 상태(state 혹은 environment)에서 (문법적으로 올바른) 어떤 식(expression) 또는 구문(statement)의 실행 이후 상태는 존재하여 하나로 결정될 수도, 존재하지 않을 수도 있고, 만약 존재한다면 이는 곧 현재 상태, 식(또는 구문), 이후 상태(또는 값)의 순서쌍이 의미 집합에 존재한다는 식으로 정의된다.&lt;/p&gt;

&lt;p&gt;이렇게 집합으로 정의된다는 것은, 곧 귀납정의(inductive definition)의 한 표현방식인 추론규칙(inference rule)으로 의미를 정의하고 서술할 수 있다는 의미이기도 하다.&lt;/p&gt;

&lt;h2 id=&quot;operational-semantics-vs-denotational-semantics-vs-axiomatic-semantics&quot;&gt;Operational Semantics vs Denotational Semantics (vs Axiomatic Semantics)&lt;/h2&gt;

&lt;p&gt;이제 정말 헷갈리기 시작하는, 그러나 헷갈려서는 안 되는 개념들이 등장하기 시작하는데, 동작 의미 구조(operational semantics)와 표시적 의미 구조(denotational semantics), 공리적 의미 구조(axiomatic semantics)이다.
(*주의: 각 용어들의 번역 용례는 &lt;a href=&quot;http://ropas.snu.ac.kr/lib/term/&quot;&gt;ROPAS 홈페이지의 번역 용례&lt;/a&gt;를 참고하긴 하지만, 번역이 너무 장황하거나 해당 페이지에 존재하지 않는 용어의 경우 임의로 번역하였다)
각각에 대해 간단하게 정리해 두겠다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;동작 의미 구조(Operational Semantics):&lt;/strong&gt; 프로그램의 수행 과정, 즉 상태의 변화를 표현하게끔 정의하는 방식의 의미 구조. 현재 상태에서 특정 식 또는 구문을 실행한 뒤 상태가 어떻게 변화할지 정의한다. 가장 단순하고 직관적이므로 프로그래밍 언어의 실행기(interpreter)를 구현할 때 주로 사용된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표시적 의미 구조(Denotational Semantics):&lt;/strong&gt; 프로그램이 수학적으로 어떻게 표현되어 각각의 식과 구문이 어떤 값을 가지게 되는지 엄밀히 정의하는 방식의 의미 구조. 프로그램 분석 분야에서 요약 실행(abstract interpretation) 과정을 수학적으로 정의할 때 필요하다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공리적 의미 구조(Axiomatic Semantics):&lt;/strong&gt; 프로그램 자체의 구체적인 수행 과정이나 의미를 정의하기보단, 그 프로그램이 실행됨으로써 입증될 수 있는 논리 명제를 얻어내게끔 정의되는 의미 구조. 이러한 특징 덕에 프로그램 논증 분야에서 굉장히 중요하게 다뤄지지만, 사실 프로그램을 실행하는 관점에서 쓸모가 있지는 않다. 완전히 같은 개념은 아니지만, Hoare logic을 떠올리면 되겠다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;big-step-vs-small-step-semantics&quot;&gt;Big Step vs Small Step Semantics&lt;/h2&gt;

&lt;p&gt;동작 의미 구조는 프로그램의 수행 과정을 그대로 정의하는 형태이기 때문에, 매우 간편하며 직관적이다.
다만 더 구체적으로 들어가면, 정의 방식이 두 가지로 나뉘게 된다.
큰 걸음 의미 구조(big step semantics)와 작은 걸음 의미 구조(small step semantics)가 바로 그것이다.
이 역시 정리해 보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;큰 걸음 의미 구조(Big Step Semantics):&lt;/strong&gt; 동작 의미 구조에서의 계산 규칙을 한 번에 끝내는 식으로 정의하는 방식. 현재 상태에서 주어진 식 또는 구문의 실행 결과, 더이상 수행할 것이 없는 최종 상태 도는 값이 된다는 것을 한 번에 표현한다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if t1 then t2 else t3&lt;/code&gt;는 계산 결과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 값을 가지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;가 가지게 되는 값, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;값을 가지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3&lt;/code&gt;가 가지게 되는 값을 가질 것이라고 단번에 정의한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작은 걸음 의미 구조(Small Step Semantics):&lt;/strong&gt; 가능한 한 최소한의 계산 과정 하나하나를 계산 규칙으로 정의하는 방식. 큰 걸음으로는 반드시 그 식 또는 구문의 계산 결과에 해당하는 상태 또는 값이 의미구조에 포함되어야 했지만, 작은 걸음에서는 계산 과정에서 새로 도출되는 식 또는 구문이 그 자리를 대체할 수 있다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if t1 then t2 else t3&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;이 가지게 될 값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;에 대해(물론 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;는 boolean 값일 것이다) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if v then t2 else t3&lt;/code&gt;가 된다고 정의하며, 또 추가로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if true then t1 else t2&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;의 값을 가지며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if false then t1 else t2&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;의 값을 가진다는 것을 각각 따로 정의한다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Jaeho Kim</name></author><category term="Study" /><category term="Programing Languages" /><category term="TaPL" /><summary type="html">헷갈리지 않도록</summary></entry><entry><title type="html">생애 첫 수업조교</title><link href="http://localhost:4000/records/KLUE/" rel="alternate" type="text/html" title="생애 첫 수업조교" /><published>2022-06-04T00:00:00+00:00</published><updated>2022-06-04T00:00:00+00:00</updated><id>http://localhost:4000/records/KLUE</id><content type="html" xml:base="http://localhost:4000/records/KLUE/">&lt;h2 id=&quot;기록물-1번&quot;&gt;기록물 1번&lt;/h2&gt;

&lt;p&gt;벌써 2년 가까이 지난 일이지만, 개인 홈페이지(겸 블로그)를 만들고 글을 쓰기로 마음먹은 뒤 아직도 서문만 쓰고 글을 쓰지 못하고 있는 나 자신을 위해, 또 아직까지도 꿈을 향하고 있는 내 원동력 벡터의 크기를 유지시켜주는 데 일조하고 있는 과거의 경험을 정리하기 위해 이 포스트를 남긴다.
또 기록하고 싶은 경험 또는 자료가 있을 때마다 아주 짧은 코멘트와 함께 정리해 두고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;첫-수업조교&quot;&gt;첫 수업조교&lt;/h2&gt;

&lt;p&gt;2020년 초여름, &lt;a href=&quot;https://www.korea.ac.kr/mbshome/mbs/university/index.do&quot;&gt;고려대학교&lt;/a&gt; &lt;a href=&quot;http://prl.korea.ac.kr/~pronto/home/&quot;&gt;소프트웨어 분석 연구실&lt;/a&gt;에 인턴을 하고 있을 당시 일이다.
오학주 교수님께서 가을학기에 컴퓨터프로그래밍2(파이썬 기초 강의)를 진행하신다는 이야기를 듣고 바로 수업조교를 해보고 싶다고 말씀드려, 조교로써 수업 준비를 도와 드리게 되었다.
처음엔 꽤나 자신있었지만, 과정은 의외로 고통스러웠으며 결국 여러 사정이 겹쳐 나를 휴학까지 하게 만들었던 활동이다. 그럼에도 즐겁고 행복했던 기억이다.
교수님께서 강의의 방향과 의도를 잡아 주시면 그에 알맞게 과제를 직접 준비하였고 매주 두 번의 수업 중 한 번은 직접 수업을 진행할 수 있는 기회를 갖기도 하였다.
그 과정 하나하나가 생생하고 의미 있었던 것 같다. 그 때의 뿌듯함을 잊지 않도록 여기에 기록물을 올려 두고자 한다.
마음 같아서는 직접 만든 과제 문제들도 함께 올려두고 싶지만 혹시 모를 문제의 발생을 막기 위해 강의평가만 pdf 형식으로 올린다.
이 강의평가들은 언제 읽어도 뿌듯하고 또 나아갈 힘을 얻게 만든다.
물론 크게 좋은 내용만 있는 건 아니다. 수업 내용에 비해 과제가 너무 어렵다든가 하는 그런 내용도 많다…
다만 개인적으로는 어느 정도 의도했기 때문에 이런 반응이 더더욱 즐거웠다.
앞으로 맡게 될 수업조교, 언젠가 맡게 될 수업을 그려보며 또 다시 읽어 보련다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/pdf/KLUE.pdf&quot;&gt;컴퓨터프로그래밍2 강의평가&lt;/a&gt; (고려대학교 강의평가 사이트 KLUE에 올라온 강의평이기 때문에 문제가 발생할 경우 비공개 처리하겠습니다)&lt;/p&gt;</content><author><name>Jaeho Kim</name></author><category term="Records" /><category term="Teaching" /><category term="Course" /><summary type="html">기록물 1번</summary></entry></feed>